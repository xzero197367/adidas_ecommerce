using System.Linq.Expressions;
using Adidas.Application.Contracts.RepositoriesContracts;
using Adidas.Application.Contracts.ServicesContracts;
using Adidas.DTOs.Common_DTOs;
using Adidas.DTOs.CommonDTOs;
using Adidas.Models;
using Mapster;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace Adidas.Application.Services
{
    public class
        GenericService<TEntity, TDto, TCreateDto, TUpdateDto> : IGenericService<TEntity, TDto, TCreateDto, TUpdateDto>
        where TEntity : BaseAuditableEntity
        where TDto : class
        where TCreateDto : class
        where TUpdateDto : BaseUpdateDto
    {
        public readonly IGenericRepository<TEntity> _repository;
        public readonly ILogger _logger;

        public GenericService(IGenericRepository<TEntity> repository, ILogger logger)
        {
            _repository = repository;
            _logger = logger;
        }

        public virtual async Task<OperationResult<TDto>> GetByIdAsync(Guid id,
            params Expression<Func<TEntity, object>>[] includes)
        {
            try
            {
                var entity = await _repository.GetByIdAsync(id, includes);

                if (entity == null)
                    return OperationResult<TDto>.Fail("Entity not found");

                return OperationResult<TDto>.Success(entity.Adapt<TDto>());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting entity by id {Id} with includes", id);
                return OperationResult<TDto>.Fail("Error getting entity by id: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<IEnumerable<TDto>>> GetAllAsync(
            Func<IQueryable<TEntity>, IQueryable<TEntity>>? queryFunc = null)
        {
            try
            {        var query = _repository.GetAll();

                if (queryFunc != null)
                {
                    query = queryFunc(query);
                }

                var entities = await query.ToListAsync();
                return OperationResult<IEnumerable<TDto>>.Success(entities.Adapt<IEnumerable<TDto>>());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting all entities");
                return OperationResult<IEnumerable<TDto>>.Fail("Error getting all entities: " + ex.Message);
            }
        }


        public virtual async Task<OperationResult<IEnumerable<TDto>>> FindAsync(
            Func<IQueryable<TEntity>, IQueryable<TEntity>> queryFunc)
        {
            try
            {
                var entities = await _repository.FindAsync(queryFunc);
                return OperationResult<IEnumerable<TDto>>.Success(entities.Adapt<IEnumerable<TDto>>());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error finding entities with predicate");
                return OperationResult<IEnumerable<TDto>>.Fail("Error finding entities with predicate: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<PagedResultDto<TDto>>> GetPagedAsync(int pageNumber, int pageSize,
            Func<IQueryable<TEntity>, IQueryable<TEntity>>? queryFunc = null)
        {
            try
            {
                var itemPaged = await _repository.GetPagedAsync(pageNumber, pageSize, queryFunc);

                return OperationResult<PagedResultDto<TDto>>.Success(itemPaged.Adapt<PagedResultDto<TDto>>());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting paged entities");
                return OperationResult<PagedResultDto<TDto>>.Fail("Error getting paged entities: " + ex.Message);
            }
        }


        public virtual async Task<OperationResult<int>> CountAsync(Expression<Func<TEntity, bool>>? predicate = null)
        {
            try
            {
                var count = await _repository.CountAsync(predicate);
                return OperationResult<int>.Success(count);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error counting entities with predicate");
                return OperationResult<int>.Fail("Error counting entities with predicate: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<bool>> ExistsAsync(Expression<Func<TEntity, bool>> predicate)
        {
            try
            {
                var exists = await _repository.ExistsAsync(predicate);
                return OperationResult<bool>.Success(exists);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking entity existence");
                return OperationResult<bool>.Fail("Error checking entity existence: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<TDto>> CreateAsync(TCreateDto createDto)
        {
            try
            {
                await ValidateCreateAsync(createDto);

                var entity = createDto.Adapt<TEntity>();
                await BeforeCreateAsync(entity);

                var createdEntityEntry = await _repository.AddAsync(entity);
              
                await _repository.SaveChangesAsync(); // Ensure changes are saved
                createdEntityEntry.State = EntityState.Deleted;
                var createdEntity = createdEntityEntry.Entity; // Extract the entity from EntityEntry
                await AfterCreateAsync(createdEntity);

                return OperationResult<TDto>.Success(createdEntity.Adapt<TDto>());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating entity");
                return OperationResult<TDto>.Fail("Error creating entity: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<IEnumerable<TDto>>> CreateRangeAsync(
            IEnumerable<TCreateDto> createDtos)
        {
            try
            {
                var createDtoList = createDtos.ToList();
                foreach (var createDto in createDtoList)
                {
                    await ValidateCreateAsync(createDto);
                }

                var entities = createDtoList.Adapt<IEnumerable<TEntity>>();
                var entityList = entities.ToList();

                foreach (var entity in entityList)
                {
                    await BeforeCreateAsync(entity);
                }

                var createdEntityEntries = await _repository.AddRangeAsync(entityList);

                await _repository.SaveChangesAsync(); // Ensure changes are saved
                // Detached tracking for the created entities
                var createdEntityList =
                    createdEntityEntries.Select(entry =>
                    {
                        entry.State = EntityState.Detached;
                        return entry.Entity;
                    }).ToList(); // Extract entities from EntityEntry collection

                foreach (var createdEntity in createdEntityList)
                {
                    await AfterCreateAsync(createdEntity);
                }

                return OperationResult<IEnumerable<TDto>>.Success(createdEntityList.Adapt<IEnumerable<TDto>>());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating entities");
                return OperationResult<IEnumerable<TDto>>.Fail("Error creating entities: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<TDto>> UpdateAsync(TUpdateDto updateDto)
        {
            try
            {
                var existingEntity = await _repository.GetByIdAsync(updateDto.Id);
                if (existingEntity == null)
                    throw new KeyNotFoundException($"Entity with id {updateDto.Id} not found");

                await ValidateUpdateAsync(updateDto.Id, updateDto);

                existingEntity = existingEntity.Adapt<TEntity>();
                await BeforeUpdateAsync(existingEntity);

                var updatedEntityEntry = await _repository.UpdateAsync(existingEntity);
                var updatedEntity = updatedEntityEntry.Entity; // Extract the entity from EntityEntry
                await _repository.SaveChangesAsync(); // Ensure changes are saved
                // Detached tracking
                updatedEntityEntry.State = EntityState.Detached;
                await AfterUpdateAsync(updatedEntity);

                return OperationResult<TDto>.Success(updatedEntity.Adapt<TDto>());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating entity with id {Id}", updateDto.Id);
                return OperationResult<TDto>.Fail("Error updating entity: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<IEnumerable<TDto>>> UpdateRangeAsync(
            IEnumerable<KeyValuePair<Guid, TUpdateDto>> updates)
        {
            try
            {
                var updateList = updates.ToList();
                var entities = new List<TEntity>();

                foreach (var update in updateList)
                {
                    var existingEntity = await _repository.GetByIdAsync(update.Key);
                    if (existingEntity == null)
                        throw new KeyNotFoundException($"Entity with id {update.Key} not found");

                    await ValidateUpdateAsync(update.Key, update.Value);
                    existingEntity = existingEntity.Adapt<TEntity>();
                    // _mapper.Map(update.Value, existingEntity);
                    await BeforeUpdateAsync(existingEntity);
                    entities.Add(existingEntity);
                }

                var updatedEntityEntries = await _repository.UpdateRangeAsync(entities);

                await _repository.SaveChangesAsync(); // Ensure changes are saved
                // Detached tracking for the updated entities
                var updatedEntityList =
                    updatedEntityEntries.Select(entry =>
                        {
                            entry.State = EntityState.Detached;
                            return entry.Entity;
                        })
                        .ToList(); // Extract entities from EntityEntry collection

                foreach (var updatedEntity in updatedEntityList)
                {
                    await AfterUpdateAsync(updatedEntity);
                }

                return OperationResult<IEnumerable<TDto>>.Success(updatedEntityList.Adapt<IEnumerable<TDto>>());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating entities");
                return OperationResult<IEnumerable<TDto>>.Fail("Error updating entities: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<TEntity>> DeleteAsync(Guid id)
        {
            try
            {
                var entity = await _repository.GetByIdAsync(id);
                if (entity == null) return OperationResult<TEntity>.Fail("Entity not found");

                await BeforeDeleteAsync(entity);
                var result = await _repository.SoftDeleteAsync(id);
                await _repository.SaveChangesAsync(); // Ensure changes are saved
                await AfterDeleteAsync(entity);

                return OperationResult<TEntity>.Success(result.Entity);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting entity with id {Id}", id);
                return OperationResult<TEntity>.Fail("Error deleting entity: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<TEntity>> DeleteAsync(TEntity entity)
        {
            try
            {
                await BeforeDeleteAsync(entity);
                var result = await _repository.SoftDeleteAsync(entity.Id);
                await _repository.SaveChangesAsync(); // Ensure changes are saved
                await AfterDeleteAsync(entity);

                return OperationResult<TEntity>.Success(result.Entity);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting entity");
                return OperationResult<TEntity>.Fail("Error deleting entity: " + ex.Message);
            }
        }

        public virtual async Task<OperationResult<IEnumerable<TEntity>>> DeleteRangeAsync(IEnumerable<Guid> ids)
        {
            try
            {
                var entities = new List<TEntity>();
                foreach (var id in ids)
                {
                    var entity = await _repository.GetByIdAsync(id);
                    if (entity != null)
                    {
                        await BeforeDeleteAsync(entity);
                        entities.Add(entity);
                    }
                }

                var result = _repository.SoftDeleteRange(entities);
                await _repository.SaveChangesAsync(); // Ensure changes are saved
                foreach (var entity in entities)
                {
                    await AfterDeleteAsync(entity);
                }

                return OperationResult<IEnumerable<TEntity>>.Success(result.Select(x => x.Entity).ToList());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting entities");
                return OperationResult<IEnumerable<TEntity>>.Fail("Error deleting entities: " + ex.Message);
            }
        }

        // Virtual methods for customization in derived classes
        public virtual Task ValidateCreateAsync(TCreateDto createDto) => Task.CompletedTask;
        public virtual Task ValidateUpdateAsync(Guid id, TUpdateDto updateDto) => Task.CompletedTask;
        public virtual Task BeforeCreateAsync(TEntity entity) => Task.CompletedTask;
        public virtual Task AfterCreateAsync(TEntity entity) => Task.CompletedTask;
        public virtual Task BeforeUpdateAsync(TEntity entity) => Task.CompletedTask;
        public virtual Task AfterUpdateAsync(TEntity entity) => Task.CompletedTask;
        public virtual Task BeforeDeleteAsync(TEntity entity) => Task.CompletedTask;
        public virtual Task AfterDeleteAsync(TEntity entity) => Task.CompletedTask;
    }
}